class Web3GameManager {
    constructor() {
        this.provider = null;
        this.signer = null;
        this.userAddress = null;
        this.cosmicYieldContract = null;
        this.usdtContract = null;
        this.isConnected = false;

        // Local state cache (updated from contract)
        this.energy = 0;
        this.plasma = 0;
        this.perHour = 0;
        this.modules = new Array(360).fill(0);
        this.moduleLevels = {};
        this.ally = null;
    }

    async init() {
        if (!window.ethereum) {
            this.showError('MetaMask or Rabby not installed. Please install a Web3 wallet.');
            return false;
        }

        // Wait for button to be in DOM
        const waitForButton = () => {
            const btn = document.getElementById('connect-wallet-btn');
            if (!btn) {
                setTimeout(waitForButton, 100);
                return;
            }
            btn.addEventListener('click', () => this.connectWallet());
        };
        waitForButton();

        // Check if already connected
        try {
            const accounts = await window.ethereum.request({ method: 'eth_accounts' });
            if (accounts.length > 0) {
                await this.connectWallet();
            }
        } catch (error) {
            console.log('No connected account found');
        }

        return true;
    }

    async connectWallet() {
        try {
            console.log('[Web3] connectWallet() called');
            console.log('[Web3] window.ethereum:', typeof window.ethereum);
            console.log('[Web3] ethers:', typeof ethers);

            const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
            console.log('[Web3] Accounts received:', accounts);

            this.userAddress = accounts[0];
            this.provider = new ethers.BrowserProvider(window.ethereum);
            this.signer = await this.provider.getSigner();
            console.log('[Web3] Signer initialized');

            // Check network
            const network = await this.provider.getNetwork();
            console.log('[Web3] Network:', network.chainId, 'Expected:', CONTRACTS.chainId);

            if (network.chainId !== BigInt(CONTRACTS.chainId)) {
                console.log('[Web3] Wrong network, switching...');
                await this.switchNetwork();
                return;
            }

            // Initialize contracts
            this.cosmicYieldContract = new ethers.Contract(CONTRACTS.cosmicYield, COSMIC_YIELD_ABI, this.signer);
            this.usdtContract = new ethers.Contract(CONTRACTS.usdt, USDT_ABI, this.signer);
            console.log('[Web3] Contracts initialized');

            this.isConnected = true;
            this.updateWalletUI();
            console.log('[Web3] Wallet UI updated');

            // Load planet data
            await this.loadPlanetData();
            console.log('[Web3] Planet data loaded');

            return true;
        } catch (error) {
            console.error('[Web3] Connection error:', error);
            console.error('[Web3] Error message:', error.message);
            console.error('[Web3] Error stack:', error.stack);
            this.showError('Failed to connect wallet: ' + error.message);
            return false;
        }
    }

    async switchNetwork() {
        try {
            await window.ethereum.request({
                method: 'wallet_switchEthereumChain',
                params: [{ chainId: '0x' + CONTRACTS.chainId.toString(16) }]
            });
        } catch (error) {
            if (error.code === 4902) {
                // Network not added, add it
                await this.addNetwork();
            } else {
                this.showError('Failed to switch network');
            }
        }
    }

    async addNetwork() {
        try {
            await window.ethereum.request({
                method: 'wallet_addEthereumChain',
                params: [{
                    chainId: '0x' + CONTRACTS.chainId.toString(16),
                    chainName: CHAIN_NAME[CONTRACTS.chainId],
                    rpcUrls: ['https://data-seed-prebsc-1-s1.binance.org:8545'],
                    blockExplorerUrls: ['https://testnet.bscscan.com'],
                    nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 }
                }]
            });
        } catch (error) {
            this.showError('Failed to add network');
        }
    }

    updateWalletUI() {
        const panel = document.getElementById('wallet-panel');
        const addressEl = document.getElementById('wallet-address');
        const networkEl = document.getElementById('wallet-network');
        const connectBtn = document.getElementById('connect-wallet-btn');

        if (this.isConnected) {
            addressEl.textContent = this.userAddress.substring(0, 6) + '...' + this.userAddress.substring(38);
            networkEl.textContent = 'Network: ' + CHAIN_NAME[CONTRACTS.chainId];
            connectBtn.style.display = 'none';
            panel.classList.add('connected');
        } else {
            addressEl.textContent = 'Not Connected';
            networkEl.textContent = 'Network: Disconnected';
            connectBtn.style.display = 'block';
            panel.classList.remove('connected');
        }
    }

    async loadPlanetData() {
        try {
            if (!this.isConnected) return;

            const planetData = await this.cosmicYieldContract.getPlanet(this.userAddress);

            this.energy = Number(planetData.energy);
            this.plasma = Number(planetData.plasma);
            this.perHour = Number(planetData.perHour);
            this.ally = planetData.ally;

            // Extract tile data (convert tiles array to module format)
            this.modules.fill(0);
            planetData.tiles.forEach((tile, index) => {
                if (tile > 0) {
                    const level = tile % 10;
                    this.modules[index] = level; // Store planet ID (1-8)
                    if (!this.moduleLevels[index]) {
                        this.moduleLevels[index] = 1;
                    }
                }
            });
        } catch (error) {
            console.error('Error loading planet data:', error);
        }
    }

    async approveUSDT(amount) {
        return this.executeTransaction(
            async () => {
                const tx = await this.usdtContract.approve(CONTRACTS.cosmicYield, amount);
                return tx;
            },
            'Approving USDT...'
        );
    }

    async buyEnergy(usdtAmount, allyAddress = '0x0000000000000000000000000000000000000000') {
        return this.executeTransaction(
            async () => {
                // First approve
                const allowance = await this.usdtContract.allowance(this.userAddress, CONTRACTS.cosmicYield);
                if (allowance < BigInt(usdtAmount)) {
                    await this.approveUSDT(usdtAmount);
                }

                // Then buy energy
                const tx = await this.cosmicYieldContract.buyEnergy(usdtAmount, allyAddress);
                return tx;
            },
            'Buying Energy...'
        );
    }

    async placeBuildings(tileIds, level) {
        return this.executeTransaction(
            async () => {
                const tx = await this.cosmicYieldContract.placeBuildings(tileIds, level);
                return tx;
            },
            'Placing Buildings...'
        );
    }

    async upgradeBuilding(tileId) {
        return this.executeTransaction(
            async () => {
                const tx = await this.cosmicYieldContract.upgradeBuilding(tileId);
                return tx;
            },
            'Upgrading Building...'
        );
    }

    async sellPlasma(plasmaAmount) {
        return this.executeTransaction(
            async () => {
                const tx = await this.cosmicYieldContract.sellPlasma(plasmaAmount);
                return tx;
            },
            'Selling Plasma...'
        );
    }

    async swapPlasmaToEnergy(plasmaAmount) {
        return this.executeTransaction(
            async () => {
                const tx = await this.cosmicYieldContract.swapPlasmaToEnergy(plasmaAmount);
                return tx;
            },
            'Swapping Plasma to Energy...'
        );
    }

    async executeTransaction(txFunction, statusMsg) {
        try {
            if (!this.isConnected) {
                this.showError('Wallet not connected');
                return null;
            }

            this.showTxModal(statusMsg);

            const tx = await txFunction();
            const txHash = tx.hash;

            // Update modal with tx hash
            const hashEl = document.getElementById('tx-hash');
            const linkEl = document.getElementById('tx-link');
            hashEl.textContent = 'TX: ' + txHash;
            linkEl.href = `https://testnet.bscscan.com/tx/${txHash}`;

            // Wait for confirmation
            const receipt = await tx.wait();

            if (receipt && receipt.status === 1) {
                document.getElementById('tx-status').textContent = '✓ Transaction Confirmed!';

                // Reload planet data
                setTimeout(async () => {
                    await this.loadPlanetData();
                    this.hideTxModal();
                }, 2000);

                return receipt;
            } else {
                throw new Error('Transaction failed');
            }
        } catch (error) {
            console.error('Transaction error:', error);
            this.hideTxModal();
            this.showError('Transaction failed: ' + (error.reason || error.message));
            return null;
        }
    }

    showTxModal(status) {
        const modal = document.getElementById('tx-modal');
        document.getElementById('tx-status').textContent = status;
        document.getElementById('tx-hash').textContent = '';
        modal.classList.add('show');
    }

    hideTxModal() {
        const modal = document.getElementById('tx-modal');
        modal.classList.remove('show');
    }

    showError(message) {
        const toast = document.getElementById('error-toast');
        document.getElementById('error-message').textContent = message;
        toast.classList.add('show');

        setTimeout(() => {
            toast.classList.remove('show');
        }, 5000);
    }

    // For compatibility with original GameManager
    save() {} // Web3 version doesn't need to save
    load() {} // Web3 version loads from contract

    updateUI() {
        // Update energy and plasma display
        const energyEl = document.getElementById('energy-value');
        const plasmaEl = document.getElementById('plasma-value');

        const formatLive = (value) => {
            const parts = value.toFixed(4).split('.');
            parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ' ');
            return parts.join('.');
        };

        if (energyEl) energyEl.textContent = formatLive(this.energy);
        if (plasmaEl) plasmaEl.textContent = formatLive(this.plasma);

        // Add animation
        if (energyEl) {
            energyEl.classList.add('value-updating');
            setTimeout(() => energyEl.classList.remove('value-updating'), 100);
        }
        if (plasmaEl) {
            plasmaEl.classList.add('value-updating');
            setTimeout(() => plasmaEl.classList.remove('value-updating'), 100);
        }

        // Update production rate
        const energyRateEl = document.getElementById('energy-rate');
        const plasmaRateEl = document.getElementById('plasma-rate');
        if (energyRateEl) energyRateEl.textContent = `+${GameHelpers.formatNumber(this.perHour)}/hr`;
        if (plasmaRateEl) plasmaRateEl.textContent = `+${GameHelpers.formatNumber(this.perHour)}/hr`;

        // Update commander info
        const commanderEl = document.getElementById('commander-name');
        const stationEl = document.getElementById('station-level');
        if (commanderEl) commanderEl.textContent = 'Commander';
        if (stationEl) stationEl.textContent = `Station Lv. 1 • ${this.getModuleCount()} modules`;

        this.updateBuildMenu();
    }

    updateBuildMenu() {
        const grid = document.getElementById('module-grid');
        if (!grid) return;

        // Only update if modal is open
        const modal = document.getElementById('build-modal');
        if (!modal || !modal.classList.contains('active')) {
            return;
        }

        const cards = grid.querySelectorAll('.module-card');
        GAME_CONFIG.MODULES.forEach((module, index) => {
            const card = cards[index];
            if (!card) return;

            const canAfford = this.energy >= module.cost;
            const currentCanAfford = card.dataset.canAfford === 'true';

            if (canAfford !== currentCanAfford) {
                card.dataset.canAfford = canAfford;
                card.classList.toggle('can-afford', canAfford);
            }
        });
    }

    getModuleCount() {
        return this.modules.filter(m => m > 0).length;
    }

    getStationLevel() {
        return 1; // Web3 version doesn't track station level separately
    }

    getRaidCooldownRemaining() {
        return 0; // Web3 version handles this differently
    }

    // Additional compatibility methods for Web3 version
    buildInitialMenu() {
        // No-op for Web3 version - UI is built from HTML
    }

    getModuleData(tileIndex) {
        const value = this.modules[tileIndex];
        if (value === 0) return null;

        const level = value; // For Web3, tiles store the level directly
        const module = GAME_CONFIG.MODULES[level - 1];

        return {
            level,
            upgrades: 0,
            module: module
        };
    }

    buildModule(tileIndex, moduleId) {
        // Web3 version uses placeBuildings contract function
        // This is a stub - actual implementation uses async contract call
        return false;
    }

    upgradeModule(tileIndex) {
        // Web3 version uses upgradeBuilding contract function
        // This is a stub - actual implementation uses async contract call
        return false;
    }

    moveModule(fromIndex, toIndex) {
        // Web3 version doesn't support moving modules
        return false;
    }

    resetGame() {
        // Web3 version doesn't allow resetting on-chain state
        return false;
    }

    swapPlasmaToEnergy(amount) {
        // Async version handled by swapPlasmaToEnergy() method
        return false;
    }

    executeRaid(winChance) {
        // Async version handled by battle() method
        return null;
    }
}

// Initialize Web3 Game Manager (wait for ethers.js to load)
window.web3Manager = new Web3GameManager();

// Wait for ethers.js to be available
function waitForEthersAndInit(attempts = 0) {
    if (typeof ethers !== 'undefined') {
        window.web3Manager.init();
    } else if (attempts < 100) {
        setTimeout(() => waitForEthersAndInit(attempts + 1), 50);
    } else {
        console.error('ethers.js failed to load');
    }
}

waitForEthersAndInit();

// ============================================
// PHASER GAME INITIALIZATION
// ============================================

